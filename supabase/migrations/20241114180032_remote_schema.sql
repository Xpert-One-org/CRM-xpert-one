create type "public"."article_type" as enum ('web', 'press');

drop trigger if exists "update_chat_updated_at" on "public"."message";

drop policy "Enable insert for authenticated users only" on "public"."mission";

drop policy "Enable insert for authenticated users only" on "public"."mission_application";

drop policy "Enable update for users based on email or admin" on "public"."profile";

alter table "public"."chat" drop constraint "chat_receiver_id_fkey";

alter table "public"."chat" drop constraint "chk_xpert_recipient_id";

drop function if exists "public"."update_chat_timestamp"();

alter table "public"."article" add column "type" article_type not null default 'web'::article_type;

alter table "public"."article" alter column "status" set default 'draft'::article_status;

alter table "public"."chat" drop column "receiver_id";

alter table "public"."chat" drop column "updated_at";

alter table "public"."chat" add column "xpert_recipient_id" uuid;

alter table "public"."mission" alter column "id" set generated by default;

alter table "public"."mission" alter column "state" set default 'in_review'::text;

alter table "public"."mission" alter column "state" set data type text using "state"::text;

alter table "public"."mission" enable row level security;

alter table "public"."profile" drop column "community_banning_explanations";

alter table "public"."profile" drop column "is_banned_from_community";

alter table "public"."chat" add constraint "chat_xpert_recipient_id_fkey" FOREIGN KEY (xpert_recipient_id) REFERENCES profile(id) ON UPDATE CASCADE ON DELETE SET NULL not valid;

alter table "public"."chat" validate constraint "chat_xpert_recipient_id_fkey";

alter table "public"."chat" add constraint "chk_xpert_recipient_id" CHECK (((type <> 'xpert_to_xpert'::chat_type) OR (xpert_recipient_id IS NOT NULL))) not valid;

alter table "public"."chat" validate constraint "chk_xpert_recipient_id";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$BEGIN
  -- Insert into the profile table
  insert into public.profile (
    id, role, firstname, lastname, email, mobile, 
    company_name, company_role, referent_id, generated_id
  )
  values (
    new.id,
    new.raw_user_meta_data->>'role',
    new.raw_user_meta_data->>'firstname',
    new.raw_user_meta_data->>'lastname',
    new.email,
    new.raw_user_meta_data->>'default_phone',
    new.raw_user_meta_data->>'company_name',
    new.raw_user_meta_data->>'company_role',
    new.raw_user_meta_data->>'referent_generated_id',
    CASE
      WHEN new.raw_user_meta_data->>'role' = 'xpert' THEN public.generate_unique_id()
      ELSE public.generate_unique_id_f()
    END  
  );
  
  -- Insert into the user_alert table
  insert into public.user_alerts (
    user_id
  )
  values (
    new.id
  );
  
  -- Check if the user is a student and insert into profile_status table
  IF new.raw_user_meta_data->>'is_student' = 'true' THEN
    insert into public.profile_status (
      profile_id, iam
    )
    values (
      new.id, 'student_apprentice'
    );
  END IF;

  return new;
END;$function$
;

create policy "Enable insert for users based on user_id"
on "public"."mission"
as permissive
for insert
to public
with check ((( SELECT auth.uid() AS uid) = created_by));


create policy "Enable insert for users based on user_id"
on "public"."mission_application"
as permissive
for insert
to public
with check ((( SELECT auth.uid() AS uid) = candidate_id));


create policy "Enable update for users based on email"
on "public"."profile"
as permissive
for update
to public
using ((( SELECT auth.uid() AS uid) = id))
with check ((( SELECT auth.uid() AS uid) = id));


CREATE TRIGGER mission_application_webhook AFTER INSERT ON public.mission_application FOR EACH ROW EXECUTE FUNCTION supabase_functions.http_request('https://wxjnrjakjwjhvsiwhelt.supabase.co/functions/v1/new-mission-application', 'POST', '{"Content-type":"application/json"}', '{}', '1000');


