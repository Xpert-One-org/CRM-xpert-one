create type "public"."admin_opinion" as enum ('positive', 'neutral', 'negative');

create type "public"."selection_column_type" as enum ('postulant', 'matching', 'etude', 'non-retenu', 'discussions', 'proposes', 'refuses', 'valides');

create type "public"."task_status" as enum ('urgent', 'pending', 'done');

create type "public"."task_subject_type" as enum ('xpert', 'supplier', 'mission', 'other');

create table "public"."selection_matching" (
    "id" bigint generated always as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "mission_id" bigint not null,
    "xpert_id" uuid not null,
    "matching_score" numeric(5,2) not null,
    "column_status" selection_column_type not null default 'postulant'::selection_column_type,
    "is_matched" boolean not null default true,
    "is_candidate" boolean not null default false
);


alter table "public"."selection_matching" enable row level security;

create table "public"."tasks" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "created_by" uuid not null,
    "assigned_to" uuid not null,
    "subject_type" task_subject_type not null,
    "xpert_id" uuid,
    "supplier_id" uuid,
    "mission_id" bigint,
    "details" text,
    "status" task_status not null default 'pending'::task_status,
    "completed_at" timestamp with time zone,
    "last_updated_at" timestamp with time zone,
    "last_updated_by" uuid
);


alter table "public"."profile" add column "admin_opinion" admin_opinion;

CREATE INDEX selection_matching_column_status_idx ON public.selection_matching USING btree (column_status);

CREATE INDEX selection_matching_mission_id_idx ON public.selection_matching USING btree (mission_id);

CREATE UNIQUE INDEX selection_matching_mission_xpert_unique_idx ON public.selection_matching USING btree (mission_id, xpert_id);

CREATE UNIQUE INDEX selection_matching_pkey ON public.selection_matching USING btree (id);

CREATE INDEX selection_matching_xpert_id_idx ON public.selection_matching USING btree (xpert_id);

CREATE INDEX tasks_assigned_to_idx ON public.tasks USING btree (assigned_to);

CREATE INDEX tasks_created_by_idx ON public.tasks USING btree (created_by);

CREATE INDEX tasks_mission_id_idx ON public.tasks USING btree (mission_id);

CREATE UNIQUE INDEX tasks_pkey ON public.tasks USING btree (id);

CREATE INDEX tasks_status_idx ON public.tasks USING btree (status);

CREATE INDEX tasks_subject_type_idx ON public.tasks USING btree (subject_type);

CREATE INDEX tasks_supplier_id_idx ON public.tasks USING btree (supplier_id);

CREATE INDEX tasks_xpert_id_idx ON public.tasks USING btree (xpert_id);

alter table "public"."selection_matching" add constraint "selection_matching_pkey" PRIMARY KEY using index "selection_matching_pkey";

alter table "public"."tasks" add constraint "tasks_pkey" PRIMARY KEY using index "tasks_pkey";

alter table "public"."selection_matching" add constraint "selection_matching_mission_id_fkey" FOREIGN KEY (mission_id) REFERENCES mission(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."selection_matching" validate constraint "selection_matching_mission_id_fkey";

alter table "public"."selection_matching" add constraint "selection_matching_xpert_id_fkey" FOREIGN KEY (xpert_id) REFERENCES profile(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."selection_matching" validate constraint "selection_matching_xpert_id_fkey";

alter table "public"."tasks" add constraint "check_subject_references" CHECK ((((subject_type = 'xpert'::task_subject_type) AND (xpert_id IS NOT NULL) AND (supplier_id IS NULL) AND (mission_id IS NULL)) OR ((subject_type = 'supplier'::task_subject_type) AND (supplier_id IS NOT NULL) AND (xpert_id IS NULL) AND (mission_id IS NULL)) OR ((subject_type = 'mission'::task_subject_type) AND (mission_id IS NOT NULL) AND (xpert_id IS NULL) AND (supplier_id IS NULL)) OR ((subject_type = 'other'::task_subject_type) AND (xpert_id IS NULL) AND (supplier_id IS NULL) AND (mission_id IS NULL)))) not valid;

alter table "public"."tasks" validate constraint "check_subject_references";

alter table "public"."tasks" add constraint "tasks_assigned_to_fkey" FOREIGN KEY (assigned_to) REFERENCES profile(id) not valid;

alter table "public"."tasks" validate constraint "tasks_assigned_to_fkey";

alter table "public"."tasks" add constraint "tasks_created_by_fkey" FOREIGN KEY (created_by) REFERENCES profile(id) not valid;

alter table "public"."tasks" validate constraint "tasks_created_by_fkey";

alter table "public"."tasks" add constraint "tasks_last_updated_by_fkey" FOREIGN KEY (last_updated_by) REFERENCES profile(id) not valid;

alter table "public"."tasks" validate constraint "tasks_last_updated_by_fkey";

alter table "public"."tasks" add constraint "tasks_mission_id_fkey" FOREIGN KEY (mission_id) REFERENCES mission(id) not valid;

alter table "public"."tasks" validate constraint "tasks_mission_id_fkey";

alter table "public"."tasks" add constraint "tasks_supplier_id_fkey" FOREIGN KEY (supplier_id) REFERENCES profile(id) not valid;

alter table "public"."tasks" validate constraint "tasks_supplier_id_fkey";

alter table "public"."tasks" add constraint "tasks_xpert_id_fkey" FOREIGN KEY (xpert_id) REFERENCES profile(id) not valid;

alter table "public"."tasks" validate constraint "tasks_xpert_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.calculate_matching_score(p_xpert_id uuid, p_mission_id bigint)
 RETURNS numeric
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_score numeric;
  v_mission mission;
  v_profile_mission profile_mission;
  v_profile_expertise profile_expertise;
  v_profile_experience profile_experience;
  v_total_criteria integer := 0;
  v_matching_criteria numeric := 0;
BEGIN
  -- Get mission and profile data
  SELECT * INTO v_mission FROM mission WHERE id = p_mission_id;
  SELECT * INTO v_profile_mission FROM profile_mission WHERE profile_id = p_xpert_id;
  SELECT * INTO v_profile_expertise FROM profile_expertise WHERE profile_id = p_xpert_id;
  SELECT * INTO v_profile_experience FROM profile_experience WHERE profile_id = p_xpert_id ORDER BY id DESC LIMIT 1;

  -- Count and check each criterion
  -- Job Title
  IF v_mission.job_title IS NOT NULL THEN
    v_total_criteria := v_total_criteria + 1;
    IF v_profile_mission.job_titles @> ARRAY[v_mission.job_title] THEN
      v_matching_criteria := v_matching_criteria + 1;
    END IF;
  END IF;

  -- Post Type
  IF v_mission.post_type IS NOT NULL THEN
    v_total_criteria := v_total_criteria + 1;
    IF v_profile_experience.post_type && v_mission.post_type THEN
      v_matching_criteria := v_matching_criteria + 1;
    END IF;
  END IF;

  -- Sector
  IF v_mission.sector IS NOT NULL THEN
    v_total_criteria := v_total_criteria + 1;
    IF v_profile_experience.sector = v_mission.sector THEN
      v_matching_criteria := v_matching_criteria + 1;
    END IF;
  END IF;

  -- Specialties
  IF v_mission.specialties IS NOT NULL THEN
    v_total_criteria := v_total_criteria + 1;
    IF v_profile_mission.specialties && v_mission.specialties THEN
      v_matching_criteria := v_matching_criteria + 1;
    END IF;
  END IF;

  -- Expertises
  IF v_mission.expertises IS NOT NULL THEN
    v_total_criteria := v_total_criteria + 1;
    IF v_profile_expertise.expertises && v_mission.expertises THEN
      v_matching_criteria := v_matching_criteria + 1;
    END IF;
  END IF;

  -- Languages
  IF v_mission.languages IS NOT NULL THEN
    v_total_criteria := v_total_criteria + 1;
    IF v_profile_expertise.maternal_language = ANY(v_mission.languages) THEN
      v_matching_criteria := v_matching_criteria + 1;
    END IF;
  END IF;

  -- Calculate final score
  IF v_total_criteria = 0 THEN
    v_score := 0;
  ELSE
    v_score := (v_matching_criteria / v_total_criteria) * 100;
  END IF;

  RETURN ROUND(v_score::numeric, 2);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.create_selection_matching()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- Insert into selection_matching
  INSERT INTO selection_matching (
    mission_id,
    xpert_id,
    created_by,
    matching_score,
    column_status,
    is_matched,
    is_candidate
  )
  VALUES (
    NEW.mission_id,
    NEW.candidate_id,
    NEW.candidate_id, -- Using candidate as created_by
    calculate_matching_score(NEW.candidate_id, NEW.mission_id),
    'postulant',
    false,
    true
  )
  ON CONFLICT (mission_id, xpert_id) DO UPDATE
  SET 
    matching_score = EXCLUDED.matching_score,
    column_status = EXCLUDED.column_status,
    is_matched = EXCLUDED.is_matched,
    is_candidate = EXCLUDED.is_candidate;

  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_task_timestamp()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
    new.last_updated_at = now();
    return new;
end;
$function$
;

grant delete on table "public"."selection_matching" to "anon";

grant insert on table "public"."selection_matching" to "anon";

grant references on table "public"."selection_matching" to "anon";

grant select on table "public"."selection_matching" to "anon";

grant trigger on table "public"."selection_matching" to "anon";

grant truncate on table "public"."selection_matching" to "anon";

grant update on table "public"."selection_matching" to "anon";

grant delete on table "public"."selection_matching" to "authenticated";

grant insert on table "public"."selection_matching" to "authenticated";

grant references on table "public"."selection_matching" to "authenticated";

grant select on table "public"."selection_matching" to "authenticated";

grant trigger on table "public"."selection_matching" to "authenticated";

grant truncate on table "public"."selection_matching" to "authenticated";

grant update on table "public"."selection_matching" to "authenticated";

grant delete on table "public"."selection_matching" to "service_role";

grant insert on table "public"."selection_matching" to "service_role";

grant references on table "public"."selection_matching" to "service_role";

grant select on table "public"."selection_matching" to "service_role";

grant trigger on table "public"."selection_matching" to "service_role";

grant truncate on table "public"."selection_matching" to "service_role";

grant update on table "public"."selection_matching" to "service_role";

grant delete on table "public"."tasks" to "anon";

grant insert on table "public"."tasks" to "anon";

grant references on table "public"."tasks" to "anon";

grant select on table "public"."tasks" to "anon";

grant trigger on table "public"."tasks" to "anon";

grant truncate on table "public"."tasks" to "anon";

grant update on table "public"."tasks" to "anon";

grant delete on table "public"."tasks" to "authenticated";

grant insert on table "public"."tasks" to "authenticated";

grant references on table "public"."tasks" to "authenticated";

grant select on table "public"."tasks" to "authenticated";

grant trigger on table "public"."tasks" to "authenticated";

grant truncate on table "public"."tasks" to "authenticated";

grant update on table "public"."tasks" to "authenticated";

grant delete on table "public"."tasks" to "service_role";

grant insert on table "public"."tasks" to "service_role";

grant references on table "public"."tasks" to "service_role";

grant select on table "public"."tasks" to "service_role";

grant trigger on table "public"."tasks" to "service_role";

grant truncate on table "public"."tasks" to "service_role";

grant update on table "public"."tasks" to "service_role";

create policy "message_crud"
on "public"."message"
as permissive
for all
to authenticated
using (true)
with check (true);


create policy "message_delete_admin"
on "public"."message"
as permissive
for delete
to authenticated
using ((EXISTS ( SELECT 1
   FROM profile
  WHERE ((profile.id = auth.uid()) AND (profile.role = 'admin'::text)))));


create policy "Admins can insert matches"
on "public"."selection_matching"
as permissive
for insert
to public
with check (( SELECT (profile.role = 'admin'::text)
   FROM profile
  WHERE (profile.id = auth.uid())));


create policy "Admins can update matches"
on "public"."selection_matching"
as permissive
for update
to public
using (( SELECT (profile.role = 'admin'::text)
   FROM profile
  WHERE (profile.id = auth.uid())))
with check (( SELECT (profile.role = 'admin'::text)
   FROM profile
  WHERE (profile.id = auth.uid())));


create policy "Admins can view all matches"
on "public"."selection_matching"
as permissive
for select
to public
using (( SELECT (profile.role = 'admin'::text)
   FROM profile
  WHERE (profile.id = auth.uid())));


CREATE TRIGGER after_mission_application_insert AFTER INSERT ON public.mission_application FOR EACH ROW EXECUTE FUNCTION create_selection_matching();

CREATE TRIGGER update_task_last_updated BEFORE UPDATE ON public.tasks FOR EACH ROW EXECUTE FUNCTION update_task_timestamp();


